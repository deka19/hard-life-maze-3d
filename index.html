<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hard Maze of Life</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); display: flex;
            justify-content: center; align-items: center; color: white;
            font-family: sans-serif; font-size: 24px; cursor: pointer;
            flex-direction: column;
        }
        #instructions { text-align: center; }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to Play</p>
            <p>Move: W, A, S, D</p>
            <p>Jump: Space</p>
            <p>Look: Mouse</p>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as CANNON from 'cannon-es';

        // --- Constants & Globals ---
        const MAZE_SIZE = 20; // Size of the maze grid
        const WALL_HEIGHT = 3;
        const CELL_SIZE = 4; // Physical size of each maze cell
        const PLAYER_HEIGHT = 1.8;
        const PLAYER_RADIUS = 0.4;
        const START_POS = new THREE.Vector3(-MAZE_SIZE * CELL_SIZE / 2 + CELL_SIZE / 2, PLAYER_HEIGHT / 2, -MAZE_SIZE * CELL_SIZE / 2 + CELL_SIZE / 2);
        const END_POS = new THREE.Vector3(MAZE_SIZE * CELL_SIZE / 2 - CELL_SIZE / 2, PLAYER_HEIGHT / 2, MAZE_SIZE * CELL_SIZE / 2 - CELL_SIZE / 2);

        let camera, scene, renderer, controls;
        let world, playerBody;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const textureLoader = new THREE.TextureLoader();
        const gltfLoader = new GLTFLoader();
        const obstacles = [];
        let isGameOver = false;

        // Maze data based on image_10.png (Simplified for brevity, a real implementation would parse the image)
        // 1 = Wall, 0 = Path. A simpler, yet hard maze.
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        init();
        animate();

        function init() {
            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111111, 0.02);
            camera = new THREE.PerspectiveCamera(75, 16 / 9, 0.1, 1000);
            camera.position.copy(START_POS);

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerWidth * 9 / 16);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 3. Physics World
            world = new CANNON.World();
            world.gravity.set(0, -20, 0); // Stronger gravity for better jumping feel
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const moonLight = new THREE.DirectionalLight(0xffffff, 0.5);
            moonLight.position.set(50, 50, 50);
            moonLight.castShadow = true;
            moonLight.shadow.camera.left = -50;
            moonLight.shadow.camera.right = 50;
            moonLight.shadow.camera.top = 50;
            moonLight.shadow.camera.bottom = -50;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);

            // 5. Controls
            controls = new PointerLockControls(camera, renderer.domElement);
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            blocker.addEventListener('click', function () { controls.lock(); });
            controls.addEventListener('lock', function () { instructions.style.display = 'none'; blocker.style.display = 'none'; });
            controls.addEventListener('unlock', function () { blocker.style.display = 'flex'; instructions.style.display = ''; });
            scene.add(controls.getObject());

            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': if (canJump === true) velocity.y += 10; canJump = false; break;
                }
            };
            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 6. Build Maze
            buildMaze();

            // 7. Create Player Body
            const playerShape = new CANNON.Sphere(PLAYER_RADIUS);
            playerBody = new CANNON.Body({ mass: 5, shape: playerShape });
            playerBody.position.copy(START_POS);
            playerBody.linearDamping = 0.9;
            world.addBody(playerBody);

            // 8. Add Hazards
            addMovingKnife(new THREE.Vector3(0, 2, 0));
            addFire(new THREE.Vector3(10, 0, 10));
            addDistraction(new THREE.Vector3(-10, 0.5, -10));

            // 9. Add End Goal
            const goalGeo = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
            const goalMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
            const goalMesh = new THREE.Mesh(goalGeo, goalMat);
            goalMesh.position.copy(END_POS);
            scene.add(goalMesh);

            window.addEventListener('resize', onWindowResize);
        }

        function buildMaze() {
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8, metalness: 0.2 });
            textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.repeat.set(1, WALL_HEIGHT / 2);
                wallMaterial.map = map;
                wallMaterial.needsUpdate = true;
            });
            textureLoader.load('https://threejs.org/examples/textures/brick_roughness.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.repeat.set(1, WALL_HEIGHT / 2);
                wallMaterial.roughnessMap = map;
                wallMaterial.needsUpdate = true;
            });

            for (let i = 0; i < MAZE_SIZE; i++) {
                for (let j = 0; j < MAZE_SIZE; j++) {
                    if (maze[i][j] === 1) {
                        const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
                        const wallMesh = new THREE.Mesh(wallGeo, wallMaterial);
                        wallMesh.position.set(
                            (j - MAZE_SIZE / 2 + 0.5) * CELL_SIZE,
                            WALL_HEIGHT / 2,
                            (i - MAZE_SIZE / 2 + 0.5) * CELL_SIZE
                        );
                        wallMesh.castShadow = true;
                        wallMesh.receiveShadow = true;
                        scene.add(wallMesh);

                        const wallShape = new CANNON.Box(new CANNON.Vec3(CELL_SIZE / 2, WALL_HEIGHT / 2, CELL_SIZE / 2));
                        const wallBody = new CANNON.Body({ mass: 0, shape: wallShape });
                        wallBody.position.copy(wallMesh.position);
                        world.addBody(wallBody);
                    }
                }
            }
            // Floor
            const floorGeo = new THREE.PlaneGeometry(MAZE_SIZE * CELL_SIZE, MAZE_SIZE * CELL_SIZE);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            textureLoader.load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg', function (map) {
                map.wrapS = THREE.RepeatWrapping;
                map.wrapT = THREE.RepeatWrapping;
                map.repeat.set(MAZE_SIZE, MAZE_SIZE);
                floorMat.map = map;
                floorMat.needsUpdate = true;
            });
            const floorMesh = new THREE.Mesh(floorGeo, floorMat);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({ mass: 0, shape: floorShape });
            floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(floorBody);
        }

        function addMovingKnife(position) {
            // Simple swinging blade using a sine wave on rotation
            const bladeGeo = new THREE.BoxGeometry(0.1, 2, 2);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.copy(position);
            blade.castShadow = true;
            scene.add(blade);
            obstacles.push({ type: 'knife', mesh: blade, initialPos: position, time: 0 });
        }

        function addFire(position) {
            // Simple particle system for fire
            const particleCount = 50;
            const particles = new THREE.BufferGeometry();
            const pMaterial = new THREE.PointsMaterial({ color: 0xff4500, size: 0.5, blending: THREE.AdditiveBlending, transparent: true });
            const positions = [];
            for (let i = 0; i < particleCount; i++) {
                positions.push((Math.random() - 0.5) * 2, Math.random() * 2, (Math.random() - 0.5) * 2);
            }
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const particleSystem = new THREE.Points(particles, pMaterial);
            particleSystem.position.copy(position);
            scene.add(particleSystem);
            obstacles.push({ type: 'fire', mesh: particleSystem });
        }

        function addDistraction(position) {
            const geo = new THREE.SphereGeometry(0.5, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(position);
            scene.add(mesh);
            obstacles.push({ type: 'distraction', mesh: mesh });
        }
        
        function checkCollisions() {
            if (isGameOver) return;
            const playerPos = playerBody.position;

            // Check Hazards
            for (const obs of obstacles) {
                const distance = playerPos.distanceTo(obs.mesh.position);
                if (obs.type === 'knife' && distance < 1.5) {
                    gameOver("You were sliced by a knife!");
                    return;
                } else if (obs.type === 'fire' && distance < 1.2) {
                    gameOver("You burned to death!");
                    return;
                } else if (obs.type === 'distraction' && distance < 0.8) {
                    // Distraction trap: teleport to a random start-ish area
                    playerBody.position.set(0, PLAYER_HEIGHT/2, 0); 
                    console.log("Distracted! Lost your way.");
                }
            }

            // Check Win Condition
            if (playerPos.distanceTo(END_POS) < CELL_SIZE / 2) {
                gameWin();
            }
        }

        function gameOver(message) {
            isGameOver = true;
            controls.unlock();
            document.getElementById('instructions').innerHTML = `<p style="font-size:36px; color:red;">GAME OVER</p><p>${message}</p><p>Refresh to restart</p>`;
            document.getElementById('blocker').style.display = 'flex';
        }

        function gameWin() {
            isGameOver = true;
            controls.unlock();
            document.getElementById('instructions').innerHTML = `<p style="font-size:36px; color:green;">YOU WIN!</p><p>You found your path.</p><p>Refresh to play again</p>`;
            document.getElementById('blocker').style.display = 'flex';
        }

        function onWindowResize() {
            camera.aspect = 16 / 9;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerWidth * 9 / 16);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameOver) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked) {
                world.step(1 / 60, delta, 3);

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // this ensures consistent movements in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                // Copy control object's rotation to player body for direction
                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);
                const yaw = new CANNON.Quaternion();
                yaw.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), euler.y);
                playerBody.quaternion.copy(yaw);

                // Apply velocity to body
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                let velX = 0, velZ = 0;
                if (moveForward) { velX += forward.x; velZ += forward.z; }
                if (moveBackward) { velX -= forward.x; velZ -= forward.z; }
                if (moveRight) { velX += right.x; velZ += right.z; }
                if (moveLeft) { velX -= right.x; velZ -= right.z; }
                
                const speed = 10;
                playerBody.velocity.x = velX * speed;
                playerBody.velocity.z = velZ * speed;
                
                // Simple ground check
                if (playerBody.position.y < PLAYER_HEIGHT / 2 + 0.1) {
                    canJump = true;
                    playerBody.velocity.y = Math.max(0, playerBody.velocity.y);
                    playerBody.position.y = PLAYER_HEIGHT / 2;
                }

                camera.position.copy(playerBody.position);
                checkCollisions();

                // Update Obstacles
                for (const obs of obstacles) {
                    if (obs.type === 'knife') {
                        obs.time += delta;
                        obs.mesh.rotation.z = Math.sin(obs.time * 2) * Math.PI / 3;
                    } else if (obs.type === 'fire') {
                         const positions = obs.mesh.geometry.attributes.position.array;
                         for(let i=1; i<positions.length; i+=3) {
                             positions[i] += delta * (Math.random() * 2 + 1);
                             if(positions[i] > 2) positions[i] = 0;
                         }
                         obs.mesh.geometry.attributes.position.needsUpdate = true;
                    }
                }
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html> 
