<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze of Life: REDUX</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* LOADER & ERROR SYSTEM */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #020202; z-index: 3000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #0f0; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #0f0;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #error-log {
            color: #ff3333; margin-top: 20px; font-size: 14px; max-width: 80%; 
            text-align: center; background: rgba(50,0,0,0.5); padding: 10px; border: 1px solid #f00;
            display: none; white-space: pre-wrap;
        }

        /* GAME UI */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 5, 0, 0.9);
            display: none; /* Hidden until loaded */
            flex-direction: column; justify-content: center; align-items: center;
            color: #fff; z-index: 2000;
        }
        h1 { 
            font-size: 5vw; text-transform: uppercase; letter-spacing: 5px; 
            color: #0f0; text-shadow: 0 0 20px #0f0; margin: 0;
        }
        .btn {
            margin-top: 30px; padding: 15px 50px; border: 2px solid #0f0; color: #0f0; background: rgba(0,20,0,0.8);
            font-size: 24px; cursor: pointer; transition: 0.3s; text-transform: uppercase;
        }
        .btn:hover { background: #0f0; color: #000; box-shadow: 0 0 30px #0f0; }

        #map-container {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; height: 600px; background: rgba(0, 10, 0, 0.95);
            border: 2px solid #0f0; z-index: 1500;
        }
        #ui-layer { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #0f0; pointer-events: none; z-index: 100; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div id="loading-text">CONNECTING TO NEON MAINFRAME...</div>
        <div id="error-log"></div>
    </div>

    <div id="map-container">
        <canvas id="mapCanvas" width="600" height="600"></canvas>
        <div style="text-align:center; color:#0f0; padding:5px;">TACTICAL MAP (LIVE)</div>
    </div>

    <div id="blocker">
        <h1>Maze of Life</h1>
        <div style="color:#aaa; margin-top:10px;">PROTOCOL: SURVIVE</div>
        <div class="btn" id="startBtn">INITIALIZE</div>
        <div style="margin-top:20px; color:#666;">W,A,S,D to Move | SPACE to Jump | Hold M for Map</div>
    </div>

    <div id="ui-layer">FIND THE GREEN BEACON</div>

    <script>
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('error-log');
            const ld = document.getElementById('loading-text');
            const sp = document.querySelector('.spinner');
            if(el && ld) {
                sp.style.display = 'none';
                ld.innerText = "SYSTEM FAILURE";
                ld.style.color = "red";
                el.style.display = 'block';
                el.innerText = `ERROR: ${msg}\nLine: ${line}`;
            }
        };
    </script>

    <script type="module">
        import * as THREE from 'https://esm.sh/three@0.160.0';
        import { PointerLockControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/PointerLockControls.js';
        import * as CANNON from 'https://esm.sh/cannon-es@0.20.0';

        // --- GLOBALS ---
        let camera, scene, renderer, controls;
        let world, playerBody;
        let lastTime = performance.now();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
        let obstacles = [];
        let isGameActive = false;
        let showMap = false;

        const MAZE_SIZE = 25;
        const CELL_SIZE = 4;
        const WALL_HEIGHT = 5;

        // --- MAZE GRID (1=Wall) ---
        const mazeGrid = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1],
            [1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
            [1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,1,1],
            [1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
            [1,1,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        // --- MAIN INIT ---
        try {
            init();
            animate();
            // Reveal Menu
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                document.getElementById('blocker').style.display = 'flex';
            }, 1500);
        } catch (e) {
            throw e; // Triggers window.onerror
        }

        function init() {
            // 1. SCENE
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.04);
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: false }); // False for better performance
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            // 2. PHYSICS
            world = new CANNON.World();
            world.gravity.set(0, -30, 0);
            const defMat = new CANNON.Material();
            const defContact = new CANNON.ContactMaterial(defMat, defMat, { friction: 0.0, restitution: 0.0 });
            world.addContactMaterial(defContact);

            // 3. LIGHTS
            scene.add(new THREE.AmbientLight(0xffffff, 0.2));
            const flashlight = new THREE.SpotLight(0x00ff00, 40, 40, Math.PI/4, 0.5, 1);
            flashlight.position.set(0,0,0);
            flashlight.target.position.set(0,0,-1);
            camera.add(flashlight);
            camera.add(flashlight.target);
            scene.add(camera);

            // 4. LEVEL
            buildMaze(defMat);
            addHazards();

            // 5. PLAYER
            const startX = (1 - MAZE_SIZE/2) * CELL_SIZE;
            const startZ = (1 - MAZE_SIZE/2) * CELL_SIZE;
            playerBody = new CANNON.Body({ mass: 80, shape: new CANNON.Sphere(1), material: defMat });
            playerBody.position.set(startX, 5, startZ);
            playerBody.linearDamping = 0.9;
            playerBody.fixedRotation = true;
            world.addBody(playerBody);

            // 6. CONTROLS
            controls = new PointerLockControls(camera, renderer.domElement);
            setupInput();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function buildMaze(mat) {
            // Generate simple textures
            const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64;
            const ctx = cvs.getContext('2d');
            
            // Wall Texture (Neon Box)
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,64,64);
            ctx.strokeStyle = '#0f0'; ctx.lineWidth=4; ctx.strokeRect(0,0,64,64);
            const wallTex = new THREE.CanvasTexture(cvs);
            wallTex.magFilter = THREE.NearestFilter;

            const boxGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const boxMat = new THREE.MeshBasicMaterial({ map: wallTex });
            const instMesh = new THREE.InstancedMesh(boxGeo, boxMat, 500);
            
            const dummy = new THREE.Object3D();
            const shape = new CANNON.Box(new CANNON.Vec3(CELL_SIZE/2, WALL_HEIGHT/2, CELL_SIZE/2));
            let idx = 0;

            for(let i=0; i<MAZE_SIZE; i++) {
                for(let j=0; j<MAZE_SIZE; j++) {
                    if(mazeGrid[i][j] === 1) {
                        const x = (j - MAZE_SIZE/2 + 0.5) * CELL_SIZE;
                        const z = (i - MAZE_SIZE/2 + 0.5) * CELL_SIZE;
                        dummy.position.set(x, WALL_HEIGHT/2, z);
                        dummy.updateMatrix();
                        instMesh.setMatrixAt(idx++, dummy.matrix);

                        const body = new CANNON.Body({ mass: 0, material: mat });
                        body.addShape(shape);
                        body.position.copy(dummy.position);
                        world.addBody(body);
                    }
                }
            }
            scene.add(instMesh);

            // Floor
            ctx.fillStyle = '#010'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#030'; ctx.fillRect(2,2,60,60);
            const floorTex = new THREE.CanvasTexture(cvs);
            floorTex.wrapS=THREE.RepeatWrapping; floorTex.wrapT=THREE.RepeatWrapping;
            floorTex.repeat.set(50,50);
            
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshBasicMaterial({ map: floorTex }));
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);
            
            const fb = new CANNON.Body({ mass:0, shape: new CANNON.Plane(), material: mat });
            fb.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            world.addBody(fb);
        }

        function addHazards() {
            // Fire
            const fPos = new THREE.Vector3(8,1,8);
            const fGeo = new THREE.BufferGeometry();
            const fArr = new Float32Array(300);
            for(let i=0; i<300; i++) fArr[i] = (Math.random()-0.5)*3;
            fGeo.setAttribute('position', new THREE.BufferAttribute(fArr, 3));
            const fMesh = new THREE.Points(fGeo, new THREE.PointsMaterial({color:0xff0000, size:0.2}));
            fMesh.position.copy(fPos);
            scene.add(fMesh);
            obstacles.push({type:'fire', mesh:fMesh, pos:fPos, range:2.5});

            // Blade
            const bGeo = new THREE.BoxGeometry(0.2, 1, 6);
            const bMesh = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({color:0x00ffff}));
            bMesh.position.set(-15, 2, -15);
            scene.add(bMesh);
            obstacles.push({type:'blade', mesh:bMesh, pos:new THREE.Vector3(-15,2,-15), range:3.5, speed:4});

            // Goal
            const gGeo = new THREE.CylinderGeometry(0, 1, 4, 16);
            const gMesh = new THREE.Mesh(gGeo, new THREE.MeshBasicMaterial({color:0x00ff00, wireframe:true}));
            gMesh.position.set(30, 2, 30);
            scene.add(gMesh);
            obstacles.push({type:'goal', mesh:gMesh, pos:new THREE.Vector3(30,2,30), range:2.0});
        }

        function setupInput() {
            const btn = document.getElementById('startBtn');
            const blk = document.getElementById('blocker');
            const mapC = document.getElementById('map-container');

            btn.addEventListener('click', () => controls.lock());
            
            controls.addEventListener('lock', () => {
                blk.style.display = 'none';
                isGameActive = true;
            });
            controls.addEventListener('unlock', () => {
                blk.style.display = 'flex';
                isGameActive = false;
                showMap = false;
                mapC.style.display = 'none';
            });

            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if(canJump) { playerBody.velocity.y = 15; canJump = false; } break;
                    case 'KeyM': if(isGameActive) { showMap = true; mapC.style.display='block'; } break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch(e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'KeyM': showMap = false; mapC.style.display='none'; break;
                }
            });
        }

        function drawMap() {
            if(!showMap) return;
            const cvs = document.getElementById('mapCanvas');
            const ctx = cvs.getContext('2d');
            const w = cvs.width, h = cvs.height;
            const cw = w/MAZE_SIZE;
            
            ctx.fillStyle = '#001'; ctx.fillRect(0,0,w,h);
            
            // Walls
            ctx.fillStyle = '#080';
            for(let i=0; i<MAZE_SIZE; i++) {
                for(let j=0; j<MAZE_SIZE; j++) {
                    if(mazeGrid[i][j]===1) ctx.fillRect(j*cw+1, i*cw+1, cw-2, cw-2);
                }
            }

            // Player
            const ww = MAZE_SIZE*CELL_SIZE;
            const px = (playerBody.position.x + ww/2)/ww * w;
            const py = (playerBody.position.z + ww/2)/ww * h;
            
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(px,py,5,0,6.28); ctx.fill();

            // Goal
            const gx = (30 + ww/2)/ww * w;
            const gy = (30 + ww/2)/ww * h;
            ctx.fillStyle = '#0f0'; ctx.font="20px Arial"; ctx.fillText("DESTINY", gx-40, gy-10);
            ctx.beginPath(); ctx.arc(gx,gy,8,0,6.28); ctx.fill();
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isGameActive) return;

            const time = performance.now();
            const delta = Math.min((time-lastTime)/1000, 0.1);
            lastTime = time;

            world.step(1/60, delta, 3);

            // Move
            const inputZ = Number(moveBackward) - Number(moveForward);
            const inputX = Number(moveRight) - Number(moveLeft);
            const vec = new THREE.Vector3(inputX, 0, inputZ).normalize();
            
            const euler = new THREE.Euler(0,0,0,'YXZ');
            euler.setFromQuaternion(camera.quaternion);
            vec.applyAxisAngle(new THREE.Vector3(0,1,0), euler.y);

            playerBody.velocity.x = vec.x * 15;
            playerBody.velocity.z = vec.z * 15;
            
            if(Math.abs(playerBody.velocity.y) < 0.1) canJump = true;
            camera.position.copy(playerBody.position);

            // Animate Hazards
            const fire = obstacles.find(o=>o.type==='fire');
            if(fire) {
                const arr = fire.mesh.geometry.attributes.position.array;
                for(let i=1; i<arr.length; i+=3) {
                    arr[i] += delta*4; if(arr[i]>4) arr[i]=0;
                }
                fire.mesh.geometry.attributes.position.needsUpdate = true;
            }
            const blade = obstacles.find(o=>o.type==='blade');
            if(blade) blade.mesh.rotation.y += delta*5;
            const goal = obstacles.find(o=>o.type==='goal');
            if(goal) { goal.mesh.rotation.x += delta; goal.mesh.rotation.y += delta; }

            // Collisions
            for(let o of obstacles) {
                if(playerBody.position.distanceTo(o.pos) < o.range) {
                    if(o.type==='goal') {
                        document.exitPointerLock();
                        alert("DESTINY ACHIEVED");
                        playerBody.position.set(0,5,0);
                    } else {
                        // Respawn
                        playerBody.position.set(0,5,0);
                        playerBody.velocity.set(0,0,0);
                    }
                }
            }

            drawMap();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
